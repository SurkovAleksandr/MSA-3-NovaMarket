# ADR-003: Задание 2. Получение агрегированных данных на фронтенде
## Автор: Сурков Александр
## Дата: 29.08.2025
## 1. Контекст
После завершения доставки покупатель может вернуться в свой личный кабинет и увидеть историю всех покупок.
В списке отображаются все заказы: 
- когда они были сделаны
- сколько стоили
- каким способом доставлены

Для каждого заказа можно открыть подробную информацию: 
- список товаров, их количество и цену
- итоговую сумму
- способ доставки и оплаты
- финальный статус заказа (доставлен, отменён)

Покупатель может скачать чек, оставить отзыв о товаре или заказать его снова.

## 3. Решение
Решение будет основываться на предыдущем результате проектирования [ADR-001-Часть 1. Проектирование событийной архитектуры.md](../Task1/ADR-001-%D0%A7%D0%B0%D1%81%D1%82%D1%8C%201.%20%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9%D0%BD%D0%BE%D0%B9%20%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D1%8B.md).

В текущей реализации все заказы хранятся в БД "Order DB". После выполнения заказа или его отмены такие заказы нельзя редактировать, но по бизнес-процессу их можно просматривать(читать). Если оставлять эти заказы в текущем хранилище, то они будут мешать текущей работе с заказами:
- они занимают место при этом доступ к ним осуществляется редко
- для работы с текущими заказами необходимо настраивать производительность хранилища. Излишние данные будут мешать этому

Исходя из этого предлагается: перенести необходимую информацию о завершенных заказах в отдельное хранилище(MongoDB). За счет разделения в UI заказов на активные и архивные можно использовать два API без использования паттерна API Composition. 

Реализация будет выглядить следующим образом.
Новый сервис "Архивные заказы" будет слушать события о завершении жизненного цикла заказа и после этого будет собирать недостающую ининформацию из других сервисов и сохранять у себя.

После того, как данные собраны и сохранены сервис "Архивные заказы" отправляет событие о завершении сохранении данных, чтобы другие сервисы могли удалить у себя устаревшие данные.

Новое событие:

| Этап                    | Тип события  | Название        |
|-------------------------|--------------|-----------------|
| Заказ перенесен в архив | Domain       | OrderArchived_D |


```plantuml
@startuml MSA-3-NovaMarket

!define C4P https://raw.githubusercontent.com/SurkovAleksandr/MSA-AgroTech-sprint-1/refs/heads/master
!includeurl C4P/c4_model/C4_Container.puml

SHOW_PERSON_OUTLINE() 

title Диаграмма контейнеров C4 системы NovaMarket. Оптимизация функционала по просмотру закрытых заказов.

' Контекст системы
Person(buyer, "Покупатель", "Покупает товары")
Person(seller, "Продавец", "Размещает товары")

System_Boundary(novaMarket, "NovaMarket Marketplace") {
  
  Container(buyerMobileApp, "Мобильное приложение покупателя", "iOS/Android", "Клиентское приложение для покупателей")
  Container(sellerMobileApp, "Мобильное приложение продавца", "iOS/Android", "Клиентское приложение для продавцов")

  Container(catalogService, "Каталог товаров", "Java", "Управление каталогом товаров, данных о наличии и ценах")
  Container(shoppingCatService, "Корзина товаров", "Java", "Товары, которые покупатель добавил в корзину")
  Container(reviewService, "Оценки, отзывы о товарах", "Java", "Отзывы покупателей о товарах")
  Container(orderService, "Заказы", "Java", "Обработка заказа: приём, проверка доступности, резервирование товаров")
  Container(orderArchiveService, "Архивные заказы", "Java", "Хранение архивных заказов")
  Container(paymentService, "Оплата", "Java", "Обработка платежей и взаимодействие с платежным шлюзом")
  Container(notificationService, "Уведомления", "Java", "Отправка уведомлений продавцам и покупателям")
  Container(deliveryService, "Доставка", "Java", "Компоновка заказа и отправка в логистическую службу")

  ContainerQueue(eventBus, "Event Bus", "Kafka", "Шина событий")

  ContainerDb(catalogDb, "Товары", "PostgreSQL", "Хранение данных о товарах")
  ContainerDb(orderDb, "Order DB", "PostgreSQL", "Хранение заказов и их статусов")
  ContainerDb(orderArchiveDb, "Архивные заказы", "MongoDB", "Хранение архивных заказов")
  ContainerDb(paymentDb, "Payment DB", "PostgreSQL", "Данные по платежам")
  ContainerDb(notificationDb, "Notification DB", "PostgreSQL", "Управление очередью уведомлений")
  ContainerDb(deliveryDb, "Delivery DB", "PostgreSQL", "Данные о доставках и заявках")

}

' Внешние системы
System_Ext(paymentGateway, "Платежный шлюз", "Внешний сервис для обработки платежей")
System_Ext(logisticsProvider, "Логистический провайдер", "Сторонний сервис для доставки товаров")
System_Ext(notificationGateway, "Шлюз уведомлений", "Внешний сервис для отправки уведомлений")
System_Ext(catalogMetaDb, "Картинки, видео товаров", "Облачное хранение", "Хранение изображений и видео товарах")

' Взаимодействия пользователей с системой
Rel(seller, sellerMobileApp, "Управление каталогом товаров")
Rel(buyer, buyerMobileApp, "Поиск и покупка товаров")


' Взаимодействия между контейнерами
Rel(sellerMobileApp, catalogService, "REST API", "Размещение товаров")
Rel(sellerMobileApp, reviewService, "REST API", "Получение отзывов о товарах")

Rel(buyerMobileApp, catalogService, "REST API", "Поиск и фильтрация товаров")
Rel(buyerMobileApp, reviewService, "REST API", "Получение отзывов о товарах")
Rel(buyerMobileApp, shoppingCatService, "REST API", "Корзина товаров пользователя")
Rel(buyerMobileApp, orderService, "REST API", "Оформление и управление заказами")
Rel(orderService, catalogService, "JSON-RPC/gRPC", "Проверка доступности товаров и резервирование")

Rel(buyerMobileApp, paymentService, "REST API", "Оплата заказа")
Rel(paymentService, paymentGateway, "Оплата товаров", "Оплата заказа через платёжный шлюз")

Rel_Up(notificationService, notificationGateway, "Уведомления о событиях", "Отправка email/SMS/Push уведомлений")
Rel(deliveryService, logisticsProvider, "Доставка товаров", "Передача товаров в доставку")

Rel(orderArchiveService, orderService, "REST API", "получение данных о заказе")
Rel(orderArchiveService, deliveryService, "REST API", "получение данных о доставке")
Rel(orderArchiveService, paymentService, "REST API", "получение данных об оплате заказа")

' Взаимодействие с базами данных
Rel(catalogService, catalogDb, "Информация о товарах")
Rel(sellerMobileApp, catalogMetaDb, "REST API", "Получение изображений и видео товарах")
Rel(catalogService, catalogMetaDb, "REST API", "Размещение изображений и видео товарах")
Rel(buyerMobileApp, catalogMetaDb, "REST API", "Получение изображений и видео товарах")
Rel(orderService, orderDb, "Информация о заказах")
Rel(orderArchiveService, orderArchiveDb, "Информация об архивных заказах")
Rel(paymentService, paymentDb, "Информация о платежах")

Rel(notificationService, notificationDb, "Уведомления")
Rel(deliveryService, deliveryDb, "Информация о доставках")

' Взаимодействие сервисов через события
Rel(orderService, eventBus, "Публикует событие о заказе", "")
Rel(eventBus, orderService, "Получение событий об облате и доставке заказа", "")
Rel(paymentService, eventBus, "Публикует события по оплате", "")
Rel(eventBus, deliveryService, "Получение событий о создании заказа", "")
Rel(deliveryService, eventBus, "Публикует статус доставки", "")
Rel(eventBus, notificationService, "Получение уведомлений", "Получение событий о заказах, оплате и доставки")
Rel(eventBus, orderArchiveService, "Закрытые заказы", "Получение информации об архивных заказах")

@enduml
```

## 4. Альтернативы
### 4.1 Альтернатива на время MVP
Данные по архивным заказам, которые нужны для отображения на UI скорее всего содержат не всю информацию о заказах, но возможно она может понадобиться для аналитики или по требованиям законодательства. 
На этапе MVP можно создать отдельные таблицы с архивными данными.

Такой вариант ускорит разработку на начальном этапе, но не пригоден для полноценного использования.
По плану планируется 40000+ заказов в день. Соответственно примерное количество записей только о заказах будет равно:  
400(кол-во дней в году) * 40 000(записей в день) = 16 000 000

Такое решение имеет недостаток: запросы для активных и архивных заказов будут приходить к одной БД тем самым конкурировать за производительность дисковых носителей. Со временем проблема будет только усугубляться.  

### 4.2 Улучшения по хранению данных
В сервисе "Архивные заказы" будет храниться не вся информация о заказах, а только необходимая для отображения на UI. Чтобы вся информация сохранялась необходимо переносить архивные данные в отдельное хранилище. На пример облако. Такой подход позволит хранить все исторические данные и позволять проводить аналитические расчеты. Это можно сделать в одной из будущих реализаций.

## 5. Недостатки, ограничения, риски
Предложенное решение содержит следующие недостатки:
- как ранее говорилось, переносимые данные по архивным заказам в сервис "Архивные заказы" могут содержать не всю информацию о заказах. 
- текущая архитектура не предусматривает выполнения аналитики

